## 3.1 트랜스포트 계층 서비스 및 개요

**트랜스포트 계층 프로토콜**

**: 서로 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 논리적 통신 제공**

논리적 통신 : 프로세스들이 동작하는 호스트들이 직접 연결된 것처럼 보임

- 트랜스포트 계층 프로토콜은 종단 시스템에서 구현
- (송신)애플리케이션 프로세스에서 수신한 메시지를 **세그먼트로 변환** 후 네트워크 계층으로 전달
- (수신)네트워크 계층에서 수신한 세그먼트를 애플리케이션이 이용하도록 처리
- 네트워크 애플리케이션에는 하나 이상의 트랜스포트 계층 프로토콜이 사용 가능

### 3.1.1 트랜스포트 계층과 네트워크 계층 사이의 관계

트랜스포트 계층 프로토콜

: 서로 다른 호스트에서 동작하는 프로세스들 사이의 논리적 통신 제공

네트워크 계층 프로토콜

: 호스트들 사이의 논리적 통신 제공

⇒ 트랜스포트 계층 프로토콜이 제공하는 서비스는 네트워크 계층 프로토콜 서비스에 의해 제약을 받는다.

(특정 서비스는 프랜스포트 프로토콜에 의해 제공될 수 있다. - 신뢰적인 데이터 전송, 암호화 등) 

### 3.1.2 인터넷 트랜스포트 계층의 개요

네트워크 계층 프로토콜 = 인터넷 프로토콜(IP)

- IP는 통신하는 호스트들 간에 세그먼트를 전달하기 위해서 최대한 노력하지만, 어떠한 보장도 하지 않는다. (best-effort delivery service)
- 세그먼트 전달을 보장하지 않으며, 순서 역시 보장하지 않음
- 세그먼트 내부 데이터에 대한 무결성을 보장하지 않음

    ⇒ **비신뢰적인 서비스**

트랜스포트 계층 프로토콜

- 기본 기능 : 종단 시스템 사이의 IP 전달 서비스를 프로세스간의 전달 서비스로 확장하는 것

    ⇒ **트랜스포트 다중화 / 역다중화**

UDP : 비신뢰적이고 비연결형 서비스(프로세스간의 데이터 전달과 오류 검출 제공)

TCP : 신뢰적이며 연결지향형 서비스(신뢰적인 데이터 전달, 혼잡 제어 등 제공)

## 3.2 다중화와 역다중화

네트워크 애플리케이션의 한 부분으로서 프로세스는 소켓을 가진다.

소켓은 애플리케이션과 트랜스포트 계층 사이의 중간 매개자 역할을 수행한다.

하나의 호스트에 하나 이상의 소켓이 있을 수 있으므로, **소켓은 유일한 식별자를 가진다.**

**역다중화 : 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업**

**다중화 : 정보를 캡슐화하고 세그먼트를 만들어 네트워크 계층으로 전달하는 작업**

⇒ 세그먼트는 소켓을 가리키는 특별한 필드를 가진다.

(출발지 포트 번호 필드 / 목적지 포드 번호 핕드)

**비연결형 다중화-역다중화 (UDP)**

1. 송신 애플리케이션 계층은 출발지 포트번호와 목적지 포트번호를 포함한 세그먼트를 생성
2. 송신 네트워크 계층은 세그먼트를 IP 데이터그램으로 캡슐화하여 수신 호스트로 전달
3. 수신 호스트는 세그먼트 안의 목적지 포트 번호를 검사하고 식별되는 소켓으로 전달

**연결지향형 다중화-역다중화 (TCP)**

TCP 소켓은 출발지 IP주소, 출발지 포트 번호, 목적지 IP주소, 목적지 포트 번호로 식별

## 3.3 비연결형 트랜스포트 : UDP

- 다중화/역다중화 기능과 간단한 오류 검사 기능을 제외하면 IP에 아무것도 추가하지 않는다.
- DNS는 UDP를 사용하는 애플리케이션 계층 프로토콜의 하나.

    ⇒ 어떠한 핸드셰이크도 수행하지 않고 메시지에 해더 필드를 추가하여 전달

**UDP의 장점**

- 무슨 데이터를 언제 보낼지에 대한 정교한 제어

    : 혼잡제어를 하지 않아 실시간 애플리케션에 적합

- 연결 설정이 없다.

    : 핸드셰이크를 하지 않아 연결에 대한 지연이 없다.

- 연결 상태가 없다.

    : 연결 상태를 유지하지 않으므로, TCP보다 더 많은 클라이언트 수용 가능

- 작은 패킷 헤더 오버헤드

    : 단지 8바이트의 오버헤드를 가진다.

▶ 신뢰적인 데이터 전송이 애플리케이션의 성능에 절대적으로 중요한 것은 아니다.

▶ UDP를 사용할 때도 신뢰적인 데이터 전송이 가능

### 3.3.1 UDP 세그먼트 구조

- UDP 헤더 + 애플리케이션 데이터(메시지)
- UDP 헤더는 2바이트씩 구성된 4개의 필드를 가짐

    (출발지 포트 번호 / 목적지 포트 번호 / 길이 / 체크섬)

- 체크섬 : 세그먼트에 오류가 발생했는지를 검사하기 위해 수신 호스트가 사용

    ⇒ (송신) : 세그먼트 안에 있는 모든 데이터를 16비트 워드 단위로 더하고 다시 1의 보수를 수행하여 전송

    (수신) : 체크섬을 포함한 모든 데이터를 16비트 워드 단위로 더하여, 합이 1111111111111111이면 오류가 없고, 하나라도 0이 나오면 오류 검출

## 3.4 신뢰성 있는 데이터 전송

신뢰적인 데이터 전송을 구현하는 것은 네트워킹에서 매우 중요한 문제

### 3.4.1 신뢰적인 데이터 전달 프로토콜의 구축

**rdt 1.0 : 완벽하게 신뢰적인 채널 상에서의 신뢰적인 데이터 전송**

○ 오류가 생길 수 없으므로, 피드백이나 속도 제어 요청등이 필요가 없다.

**rdt 2.0 : 비트 오류가 있는 채널 상에서의 신뢰적인 데이터 전송**

○ 자동 재전송 요구(ARQ) 프로토콜 사용

⇒ 1. 오류 검출 : 체크섬 필드를 사용해서 오류 검출

2. 수신자 피드백 : 긍정 확인응답(ACK)과 부정 확인응답(NAK)로 수신 피드백

3. 재전송 : 오류가 생긴 패킷을 재전송

○ ACK,NAK의 손상과 중복 패킷같은 문제 발생

⇒ 데이터 패킷에 순서 번호(sequence number)를 삽입.(rdt 2.1)

(순서 번호의 격차로 손실 패킷을 검사하고, 중복 번호로 패킷의 중복 검사)

**rdt 3.0 : 비트 오류와 손실 있는 채널 상에서의 신뢰적 데이터 전송**

○ 송신자는 데이터 패킷이 손실되었는지, ACK가 손실되었는지, 단순히 지연된건지 알지 못함

○ 이러한 모든 경우에 행동하는 방식은 **재전송**

○ 타이머를 이용하여 일정 시간 안에 ACK를 수신하지 못하면 재전송

### 3.4.2 파이프라인된 신뢰적 데이터 전송 프로토콜

rdt3.0은 기능적으로 정확한 프로토콜이나, 전송-후-대기 프로토콜이다.

⇒ 성능면에서 안좋을 수 있다.(특히 형편없는 송신자 이용률을 가질 수 있다.)

▶ 확인응답(ACK)를 기다리지 않고 여러 패킷을 전송하여 문제 해결 (**파이프 라이닝 pipelining**)

- 순서 번호의 범위가 크게하여, 각각의 전송 패킷이 유일한 번호를 가지고 전송 중이거나, 확인 응답이 안된 패킷을 확인
- 송신측과 수신측은 한 개 이상의 패킷을 버퍼링하여, 확인응답이 된 패킷을 체크
- 오류 회복으로 Go-Back-N(N부터 반복)과 SR(선택적 반복)이 있다.

### 3.4.3 Go-Back-N (N부터 반복)

- 송신자는 확인응답을 기다리지 않고 여러 패킷을 전송 가능
- 파이프라인에서 확인안된 패킷은 N보다 크지 않아야 함
- N = 윈도우 크기 / GBN 프로토콜 = 슬라이딩 윈도우 프로토콜
- 윈도우가 차 있지 않으면 패킷을 생성하고 송신
- 윈도우가 가득 차 있으면 데이터를 상위 계층으로 반환
- 수신자는 순서가 잘못된 패킷을 버퍼링 할 필요가 없으며 버림

    (어차피 N부터 다시 재전송 해주니까)

- 순서번호, 누적 확인응답, 체크 섬, 타임아웃/재전송을 포함

### 3.4.4 SR, Selective Repeat (선택적 반복)

GBN의 성능문제 : 패킷 하나의 오류때문에 많은 패킷을 불필요하게 재전송해야함

- SR은 수신자가 오류가 발생했다고 의심한 패킷만을 재전송
- 필요에 따라 각각의 재전송은 개별적인 확인응답을 요구함
- 수신자는 패킷의 순서와 무관하게 확인을 응답
- 순서가 틀인 패킷은 버퍼에 보관하고, 손실된 패킷이 수신되면 함께 상위 계층에 전달

**매커니즘**

- 체크섬 : 전송된 패킷 안의 비트오류를 검출하는데 사용
- 타이머 :
- 순서번호
- 확인응답
- 부정 확인응답
- 윈도우, 파이프라이닝

## 3.5 연결지향형 트랜스포트 : TCP

### 3.5.1 TCP 연결

- TCP는 데이터를 전송하기 전에 **핸드셰이크**를 먼저 해야함 → 연결지향형
- TCP 프로토콜은 오직 종단시스템에서만 동작하고, 중간 요소들은 감지 못함(연결 유지X)
- 전이중(full-duplex) 서비스 제공
- 항상 단일 송신자와 단일 수신자 사의의 점대점(point-to-point)이다.

**3-way handshake**

통신하기 앞서, 논리적인 접속을 성립하기 위해 하는 과정

1. 클라이언트가 서버에게 SYN(x) 패킷을 보냄
2. 서버는 SYN(x) 패킷을 수신하고, 클라이언트로 ACK(x+1)와 SYN(y)을 보냄
3. 클라이언트는 서버의 응답을 수신하고 ACK(y+1)를 보내며 연결 성립

 

### 3.5.2 TCP 세그먼트 구조

- TCP 헤더 + 데이터
- 출발지 포트 번호 / 목적지 포트 번호 (각 2바이트)
- 32비트 순서번호 필드 / 32비트 확인응답필드 (신뢰적인 데이터 전송 서비스 구현)
- 4비트 헤더길이 / 플래그 필드
- 16비트 수신 윈도우 ⇒ 흐름제어에 사용
- 16비트 체크섬 / 16비트 긴급 데이터 포인터 필드

### 3.5.4 신뢰적인 데이터 전달

- TCP는 신뢰적 데이터 전달 서비스 제공(손실이나 중복이 없고 순서 유지 보장)
- 송신자는 타임 아웃을 이용하여 손실 세그먼트를 복구

    (상위 애플리케이션으로부터 데이터 - 타이머 타임아웃 - ACK 수신)

- TCP의 오류 복구는 GBN와 SR의 혼합
- 선택적 확인응답 : TCP 수신자가 순서가 틀린 세그먼트에 대해서 확인 응답

### 3.5.5 흐름제어

- TCP는 송신자가 수신자의 버퍼를 오버플로 시키는 것을 방지하기 위해 흐름제어 서비스 제공
- 수신 애플리케이션이 읽는 속도와 송신자의 전송속도를 일치시킴
- 혼잡제어와 비슷(송신자의 억제)하지만, 명백히 다른 목적을 가짐
- TCP는 송신자가 수신 윈도우라는 변수를 유지하여 흐름 제어

## 3.6 혼잡제어

한 라우터에 데이터가 몰려, 데이터를 처리할 수 없으며 네트워크가 혼잡해지고 오버플로나 데이터 손실을 발생할 때, 송신측의 전송 속도를 강제로 제어하는 작업

- 종단간의 혼잡제어

    ○ 네트워크 계층은 혼잡제어를 위해 트랜스포트 계층에게 어떠한 지원도 하지 않는다. 

    ○ 네트워크 혼잡을 단지 관찰된 네트워크 행동을 기반으로 종단시스템이 추측

    ○ 왕복 지연값을 네트워크 혼잡 증가로 인지하고 사용

- 네트워크 지원 혼잡제어

    ○ 네트워크 계층 구성요소는 혼잡 상태에 관련하여, 송신자에게 직접적인 피드백 제공

    ○ 제공할 수 있는 전송률을 송신자에게 명확히 알려주기도 함

## 3.7 TCP 혼잡제어

- TCP는 종단간의 혼잡제어를 사용해야 함
- 네트워크 혼잡에 따라 연결에 트래픽을 보내는 전송률을 각 송신자가 제한하도록 함
- cwnd로 표시되는 혼잡 윈도우가 송신자의 전송률을 제한

**슬로 스타트(slow start)**

- 패킷을 하나씩 보내며 시작
- 확인 응답을 받을 때마다 윈도우의 크기를 1씩 증가
- TCP 전송률은 작은값으로 시작하여, 슬로 스타트 단계동안 지수적으로 증가

**혼잡 회피**

- 혼잡 회피 상태로 들어갈 때, cwnd값은 혼잡 직전의 값의 반이 됨
- 지수적 증가가 아닌, 선형증가를 통해 cwnd값을 늘려감

**빠른 회복(fast recovery)**

- TCP Tahoe

    : 초기버전으로 타임아웃이 되거나 3개의 중복 ACK에 의한 손실이 발생하면 무조건 혼잡윈도우를 1MSS로 줄이고, 슬로 스타트 단계로 들어감

- TCP Reno

    : Tahoe 이후에 나온 버전으로 3개의 중복 ACK에 의한 손실이 발생하면 혼잡윈도우 크기를 1MSS로 줄이는게 아니라 현재 혼잡윈도우 크기의 절반으로 줄인다음 1MSS씩 선형으로 증가
